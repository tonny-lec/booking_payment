---
doc_type: "adr"
id: "0002"
title: "RefreshTokenローテーション戦略"
status: "accepted"
date: "2026-01-18"
deciders: ["Architecture Team", "Security Team"]
---

# ADR-002: RefreshTokenローテーション戦略

## ステータス

Accepted

## コンテキスト

ADR-001でJWT認証方式を採用した。JWTのAccessTokenは短命（15分）であるため、ユーザー体験を損なわずに継続的なセッションを維持するためにRefreshTokenが必要となる。

RefreshTokenは長期間有効であるため、漏洩時のリスクが高い。このリスクを軽減するための戦略を決定する必要がある。

### 検討すべき要件

1. **セキュリティ**: トークン漏洩時の被害を最小化
2. **ユーザー体験**: 頻繁な再ログインを回避
3. **複数デバイス対応**: 同一ユーザーの複数デバイスからのアクセス
4. **検知能力**: 不正使用の検知と対応

## 決定

**Rotating Refresh Token（回転方式）を採用する。**

RefreshTokenを使用するたびに新しいトークンを発行し、古いトークンを即座に無効化する。

### 採用する構成

| 項目 | 決定事項 |
|------|----------|
| ローテーション方式 | 使用ごとに新トークン発行 |
| 同時有効トークン数 | 最大5個（複数デバイス対応） |
| 再利用検知 | 有効（全トークン即時失効） |
| 有効期限 | 7日（Remember Me: 30日） |

### シーケンス

```
Client                    IAM                      DB
  │                        │                        │
  │ POST /auth/refresh     │                        │
  │ {refresh_token: RT1}   │                        │
  ├───────────────────────>│                        │
  │                        │ SELECT WHERE hash=RT1  │
  │                        ├───────────────────────>│
  │                        │ {valid, not revoked}   │
  │                        │<───────────────────────┤
  │                        │                        │
  │                        │ BEGIN TRANSACTION      │
  │                        │  - UPDATE: revoke RT1  │
  │                        │  - INSERT: RT2         │
  │                        ├───────────────────────>│
  │                        │                        │
  │ {access_token,        │                        │
  │  refresh_token: RT2}  │                        │
  │<───────────────────────┤                        │
```

## 検討した選択肢

### 選択肢1: 固定RefreshToken（不採用）

RefreshTokenを発行後、有効期限まで同一トークンを使用し続ける。

```
┌────────────────────────────────────────────┐
│          RefreshToken有効期間（7日）         │
├────────────────────────────────────────────┤
│ 発行 ────────────────────────────────> 期限 │
│   ↑                                        │
│   └── 漏洩した場合、7日間悪用可能          │
└────────────────────────────────────────────┘
```

**メリット:**
- 実装がシンプル
- クライアント側の状態管理が容易

**デメリット:**
- 漏洩時に有効期限まで悪用される
- 不正使用の検知が困難

### 選択肢2: Sliding Window方式（不採用）

使用するたびに有効期限を延長するが、トークン自体は変更しない。

**メリット:**
- 実装がシンプル
- アクティブユーザーのセッション維持

**デメリット:**
- 選択肢1と同様のセキュリティリスク
- 無期限に有効になりうる

### 選択肢3: Rotating Refresh Token（採用）

使用ごとに新しいトークンを発行し、古いトークンを無効化する。

```
┌──────────────────────────────────────────────────────────────┐
│              Rotating Refresh Token                           │
├──────────────────────────────────────────────────────────────┤
│                                                               │
│  RT1 ──使用──> RT2 ──使用──> RT3 ──使用──> RT4 ...            │
│   │            │            │                                 │
│   └──無効化    └──無効化    └──無効化                         │
│                                                               │
│  漏洩した旧トークンは即座に無効                               │
│  再利用を検知したら全トークン失効                             │
│                                                               │
└──────────────────────────────────────────────────────────────┘
```

**メリット:**
- 漏洩したトークンは次回使用時に無効化される
- 再利用を検知可能（攻撃の兆候）
- トークンの有効ウィンドウが実質的に短縮

**デメリット:**
- 実装の複雑さ増加
- クライアントが新トークンを保存し損ねた場合の対応

### 選択肢4: Token Binding（将来検討）

トークンをクライアント証明書やデバイスに紐づける。

**メリット:**
- 漏洩しても他デバイスで使用不可

**デメリット:**
- クライアント実装の複雑さ
- ブラウザサポートの制限

**結論:** 将来的なオプションとして記録するが、現時点では選択肢3を採用。

## 結果

### 正の影響

1. **漏洩リスク軽減**: トークンの実質的な有効期間が使用間隔に限定
2. **攻撃検知**: 再利用（replay）を検知可能
3. **即時対応**: 再利用検知時に全セッション強制終了

### 負の影響

1. **実装複雑性**: トランザクション管理が必要
   - **緩和策**: 明確なシーケンス図とテストケースを用意
2. **ネットワーク障害時のリスク**: 新トークン受信前に接続断
   - **緩和策**: クライアントにリトライロジックを実装
3. **並行リクエスト問題**: 同一トークンでの並行リフレッシュ
   - **緩和策**: 短いGrace Period（5秒）を設けて旧トークンも許容

### 再利用検知時の対応

```java
public void handleTokenReplay(UserId userId, RefreshTokenId replayedTokenId) {
    // 1. 当該ユーザーの全RefreshTokenを即座に失効
    refreshTokenRepository.revokeAllByUserId(userId);

    // 2. セキュリティイベントを発行
    eventPublisher.publish(new RefreshTokenReplayDetected(
        userId,
        replayedTokenId,
        Instant.now()
    ));

    // 3. ユーザーに通知（オプション）
    notificationService.sendSecurityAlert(
        userId,
        SecurityAlertType.SESSION_COMPROMISED
    );
}
```

### 複数デバイス対応

| シナリオ | 動作 |
|----------|------|
| 新デバイスでログイン | 新しいRefreshToken発行（最大5個まで） |
| 6個目のトークン発行 | 最古のトークンを自動失効 |
| 1デバイスでログアウト | 当該トークンのみ失効 |
| 全デバイスからログアウト | 全RefreshToken失効 |

## 関連決定

- ADR-001: JWT認証方式の採用
- ADR-003: Brute-force対策の閾値設定

## 参考資料

- OAuth 2.0 Security Best Current Practice (Section 4.13)
- RFC 6749: OAuth 2.0 Authorization Framework
- Auth0: Refresh Token Rotation
