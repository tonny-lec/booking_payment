package com.booking.iam.domain.event;

import com.booking.iam.domain.model.UserId;
import com.booking.shared.event.DomainEvent;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;
import org.junit.jupiter.params.provider.NullAndEmptySource;

import java.time.Instant;
import java.util.UUID;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

/**
 * Unit tests for {@link UserLoggedIn} domain event.
 */
@DisplayName("UserLoggedIn")
class UserLoggedInTest {

    private static final String CLIENT_IP = "192.168.1.100";
    private static final String USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64)";

    private UserId createUserId() {
        return UserId.generate();
    }

    @Nested
    @DisplayName("Factory methods")
    class FactoryMethods {

        @Test
        @DisplayName("create() should generate event with auto-generated ID and timestamp")
        void createShouldGenerateEventWithAutoGeneratedIdAndTimestamp() {
            // Given
            UserId userId = createUserId();
            Instant beforeCreate = Instant.now();

            // When
            UserLoggedIn event = UserLoggedIn.create(userId, CLIENT_IP, USER_AGENT);

            // Then
            assertThat(event).isNotNull();
            assertThat(event.eventId()).isNotNull();
            assertThat(event.userId()).isEqualTo(userId);
            assertThat(event.occurredAt()).isAfterOrEqualTo(beforeCreate);
            assertThat(event.occurredAt()).isBeforeOrEqualTo(Instant.now());
            assertThat(event.userAgent()).isEqualTo(USER_AGENT);
        }

        @Test
        @DisplayName("create() should mask client IP address")
        void createShouldMaskClientIpAddress() {
            // Given
            UserId userId = createUserId();

            // When
            UserLoggedIn event = UserLoggedIn.create(userId, "192.168.1.100", USER_AGENT);

            // Then
            assertThat(event.clientIp()).isEqualTo("192.168.1.***");
        }

        @Test
        @DisplayName("create() should generate unique event IDs")
        void createShouldGenerateUniqueEventIds() {
            // Given
            UserId userId = createUserId();

            // When
            UserLoggedIn event1 = UserLoggedIn.create(userId, CLIENT_IP, USER_AGENT);
            UserLoggedIn event2 = UserLoggedIn.create(userId, CLIENT_IP, USER_AGENT);

            // Then
            assertThat(event1.eventId()).isNotEqualTo(event2.eventId());
        }

        @Test
        @DisplayName("create() should throw NullPointerException for null userId")
        void createShouldThrowExceptionForNullUserId() {
            assertThatThrownBy(() -> UserLoggedIn.create(null, CLIENT_IP, USER_AGENT))
                    .isInstanceOf(NullPointerException.class)
                    .hasMessageContaining("User ID must not be null");
        }

        @Test
        @DisplayName("of() should create event with all fields specified")
        void ofShouldCreateEventWithAllFieldsSpecified() {
            // Given
            UUID eventId = UUID.randomUUID();
            UserId userId = createUserId();
            Instant occurredAt = Instant.now().minusSeconds(60);
            String maskedIp = "192.168.1.***";

            // When
            UserLoggedIn event = UserLoggedIn.of(eventId, userId, occurredAt, maskedIp, USER_AGENT);

            // Then
            assertThat(event.eventId()).isEqualTo(eventId);
            assertThat(event.userId()).isEqualTo(userId);
            assertThat(event.occurredAt()).isEqualTo(occurredAt);
            assertThat(event.clientIp()).isEqualTo(maskedIp);
            assertThat(event.userAgent()).isEqualTo(USER_AGENT);
        }
    }

    @Nested
    @DisplayName("DomainEvent interface")
    class DomainEventInterface {

        @Test
        @DisplayName("should implement DomainEvent interface")
        void shouldImplementDomainEventInterface() {
            // Given
            UserLoggedIn event = UserLoggedIn.create(createUserId(), CLIENT_IP, USER_AGENT);

            // Then
            assertThat(event).isInstanceOf(DomainEvent.class);
        }

        @Test
        @DisplayName("aggregateId() should return user ID as UUID")
        void aggregateIdShouldReturnUserIdAsUuid() {
            // Given
            UserId userId = createUserId();
            UserLoggedIn event = UserLoggedIn.create(userId, CLIENT_IP, USER_AGENT);

            // Then
            assertThat(event.aggregateId()).isEqualTo(userId.value());
        }

        @Test
        @DisplayName("eventType() should return class simple name")
        void eventTypeShouldReturnClassSimpleName() {
            // Given
            UserLoggedIn event = UserLoggedIn.create(createUserId(), CLIENT_IP, USER_AGENT);

            // Then
            assertThat(event.eventType()).isEqualTo("UserLoggedIn");
        }
    }

    @Nested
    @DisplayName("IP address masking")
    class IpAddressMasking {

        @ParameterizedTest
        @DisplayName("should mask IPv4 addresses correctly")
        @CsvSource({
                "192.168.1.100, 192.168.1.***",
                "10.0.0.1, 10.0.0.***",
                "255.255.255.255, 255.255.255.***",
                "1.2.3.4, 1.2.3.***"
        })
        void shouldMaskIpv4Addresses(String input, String expected) {
            // When
            String masked = UserLoggedIn.maskIpAddress(input);

            // Then
            assertThat(masked).isEqualTo(expected);
        }

        @ParameterizedTest
        @DisplayName("should mask IPv6 addresses correctly")
        @CsvSource({
                "2001:0db8:85a3:0000:0000:8a2e:0370:7334, 2001:0db8:85a3:***",
                "fe80:0:0:0:200:f8ff:fe21:67cf, fe80:0:0:***",
                "::1, ::***"
        })
        void shouldMaskIpv6Addresses(String input, String expected) {
            // When
            String masked = UserLoggedIn.maskIpAddress(input);

            // Then
            assertThat(masked).isEqualTo(expected);
        }

        @ParameterizedTest
        @DisplayName("should handle null and empty IP addresses")
        @NullAndEmptySource
        void shouldHandleNullAndEmptyIpAddresses(String input) {
            // When
            String masked = UserLoggedIn.maskIpAddress(input);

            // Then
            assertThat(masked).isEqualTo(input);
        }

        @Test
        @DisplayName("should mask unknown format by hiding half")
        void shouldMaskUnknownFormatByHidingHalf() {
            // Given
            String unknownFormat = "abcdef";

            // When
            String masked = UserLoggedIn.maskIpAddress(unknownFormat);

            // Then
            assertThat(masked).isEqualTo("abc***");
        }
    }

    @Nested
    @DisplayName("Value object semantics")
    class ValueObjectSemantics {

        @Test
        @DisplayName("equals() should return true for same values")
        void equalsShouldReturnTrueForSameValues() {
            // Given
            UUID eventId = UUID.randomUUID();
            UserId userId = createUserId();
            Instant occurredAt = Instant.now();

            UserLoggedIn event1 = UserLoggedIn.of(eventId, userId, occurredAt, CLIENT_IP, USER_AGENT);
            UserLoggedIn event2 = UserLoggedIn.of(eventId, userId, occurredAt, CLIENT_IP, USER_AGENT);

            // Then
            assertThat(event1).isEqualTo(event2);
        }

        @Test
        @DisplayName("equals() should return false for different event IDs")
        void equalsShouldReturnFalseForDifferentEventIds() {
            // Given
            UserId userId = createUserId();
            Instant occurredAt = Instant.now();

            UserLoggedIn event1 = UserLoggedIn.of(UUID.randomUUID(), userId, occurredAt, CLIENT_IP, USER_AGENT);
            UserLoggedIn event2 = UserLoggedIn.of(UUID.randomUUID(), userId, occurredAt, CLIENT_IP, USER_AGENT);

            // Then
            assertThat(event1).isNotEqualTo(event2);
        }

        @Test
        @DisplayName("hashCode() should be consistent with equals()")
        void hashCodeShouldBeConsistentWithEquals() {
            // Given
            UUID eventId = UUID.randomUUID();
            UserId userId = createUserId();
            Instant occurredAt = Instant.now();

            UserLoggedIn event1 = UserLoggedIn.of(eventId, userId, occurredAt, CLIENT_IP, USER_AGENT);
            UserLoggedIn event2 = UserLoggedIn.of(eventId, userId, occurredAt, CLIENT_IP, USER_AGENT);

            // Then
            assertThat(event1.hashCode()).isEqualTo(event2.hashCode());
        }
    }

    @Nested
    @DisplayName("String representation")
    class StringRepresentation {

        @Test
        @DisplayName("toString() should contain relevant information")
        void toStringShouldContainRelevantInformation() {
            // Given
            UserId userId = createUserId();
            UserLoggedIn event = UserLoggedIn.create(userId, CLIENT_IP, USER_AGENT);

            // Then
            String str = event.toString();
            assertThat(str)
                    .contains("UserLoggedIn")
                    .contains(event.eventId().toString())
                    .contains(userId.toString());
        }

        @Test
        @DisplayName("toString() should contain masked IP, not original")
        void toStringShouldContainMaskedIp() {
            // Given
            UserLoggedIn event = UserLoggedIn.create(createUserId(), "192.168.1.100", USER_AGENT);

            // Then
            assertThat(event.toString())
                    .contains("192.168.1.***")
                    .doesNotContain("192.168.1.100");
        }
    }
}
